# 大纲

- 设计思路
  - 模块的划分
  - 技术选型
  - 前车之鉴
- 通讯协议
  - tcp
  - websocket
  - udp
- 消息可靠性
  - 消息确认机制
  - 消息顺序
  - 消息去重
- 消息投递
  - 群聊消息投递
  - 消息存储策略
  - 协议
- 分布式架构的设计
  - 组件的选择
  - 消息路由
  - 缓存和数据库

# 通讯协议

## TCP

### 使用 TCP 的优缺点

优点:

1. 长连接有转态协议
2. 可靠送达

缺点:

1. 可靠传输确认机制需要额外资源
2. 浏览器不支持

### 为何需要心跳

1. 运营商可能切断连接
2. 判断服务端, 客户端是否可用
3. TCP 自带 keepalive 只能确保连接可用, 而无法判断应用状态

# 消息存储和投递

消息采用写扩散方式保存, 消息id除按时间递增排序外无其他语义

## 消息投递

### 消息可靠投递, 防丢失

- 由于从客户端到服务器, 或服务器到客户端的途中消息都可能丢失, 为确保消息可靠的投递, 服务端或客户端在发出消息后需要有一套确认送达的机制.
- 消息重传由客户端负责, 每次发送一条消息完整流程总共需要经历四个消息收发
- 发送方发送到服务器, 如果超时时间内没有收到服务器返回的 ack/msg 则重发, 收到 ack/msg 后则等待接收方已收到的ack/notify, 未收到则重发
- 服务器收到发送方消息后判断接收方是否在线, 不在线则直接返回 ack/notify 到发送方, 在线则投递给接收方, 接收方收到消息后发送一条 ack/req 到服务器, 服务器再将 ack/notify 消息投递给发送方,
  则发送方确认消息送达

### 如何保证接收方和发送方消息顺序一致

- 用户A发短时间内先后两条消息, 由于网络因素可能导致用户B先收到后发的消息.
- 发送方发送消息时附带会话级别seq, seq根据上一条发送方消息的seq自增一次
- 一个用户同时使用两个端发送消息的情况, 如果一端网络异常消息丢失, 则seq可能乱, 但是暂不考虑此情况
- 可考虑使用添加发送时间戳方案

### 如何保证接收方消息不重复

- 客户端发送消息时获取消息ID, 收到后根据消息 ID 去重

### 如何保证接受有序性

- 每个用户的所有消息使用递增 seq 来确保有序性, 这个 seq 保证递增, 且绝大部分时候有序地递增以确保顺序, 附带检查消息遗漏功能.

### 多端何如同步

- 在线时多端同时推送, 上线同步时通过本地 seq 拉取消息

## 消息存储

### 消息ID如何生成

- 由于消息ID只需要保证唯一性和递增即可, 所以使用 snowflake 或 leaf 生成.

### 读扩散还是写扩散

- 读扩散, 消息只存一份

只存一份, 写的压力比较小, 且节约空间, 但是读的压力会比较大, 尤其是群消息

- 写扩散, 消息保存多份(采用此方案)

每个用户保存一份, 发送消息时写入的压力较大, 尤其是群消息, 群成员多的情况下, 万人群发一条消息则写入一万次

优点: 读的压力会减小, 而且做消息撤回, 已读未读等功能比较方便, 消息 为读多写少的数据, 存多发有利于提升性能

### 消息何时存储, 如何避免重复

- 服务端收到发送消息请求则立即存储消息, 确保不会丢失
- 客户端重发消息使用相同消息ID, 服务端只保存最后一次的状态, 存在则更新, 不存在就创建

## 群聊消息投递

## 协议

# 项目目录及模块的划分

## client

## api

## group

## 其他
