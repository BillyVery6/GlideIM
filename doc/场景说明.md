## 鉴权相关

- 建立长连接

1. 客户端长连接到服务端后将分配一个临时 ID
2. 客户端登录之前使用临时 ID 交互

- 登录

1. 客户端访问服务端登录接口, 提交用户名, 密码, 设备标识
2. 服务端收到消息后验证成功, 判断是否已有相同设备登录, 有则挤下线
3. 服务端返回登录成功和 token
4. 客户端保存token,下次登录使用

## 群相关

- 群创建, 添加初始成员

1. 客户端提交群名称, 邀请成员ID
2. 服务端数据库创建群, 添加群成员
3. 服务端将群加载到内存, 初始化
4. 给群成员发送新增一个群通知, 建群接口返回创建成功
5. 客户端添加群到本地缓存的联系人列表

## 发送消息

假设两个用户 s (sender), r (receiver)

1. s 在客户端点击发送按钮
2. 客户端从服务端获取一个消息ID
3. 构建消息, 使用获取到的消息 ID, 并且添加一个 c_seq, c_seq 为当前会话 s 发送的消息最后一条消息的c_seq+1, 如果s没有发送过消息, 则c_seq为1
4. s 客户端发送到服务端, 并启动一个定时器等待服务端回复确认收到消息(ack)
    1. 若 s 客户端一段时间内未收到 ack, 判定为发送失败, 重新发送, 若干轮重试失败后则显示发送失败
5. 服务端收到 s 客户端的消息后, 立即存储该消息并分发, 若 r 在线则发送给 r, 发送前在消息中添加一个 r 的全局消息 g_seq
    1. 若 r 不在线则保存到 r 的离线消息列表, 之后服务端返回一个 ack 消息给 s
6. r 收到消息后, 将消息根据 c_seq 和消息ID 综合排序放入会话的消息列表
    1. 若该消息发送者上一条消息的 c_seq 和当前收到的 c_seq 不连续则可能丢失了消息, 则拉取一次当前会话的消息
    2. 若该消息的 g_seq 和本地存储的 g_seq 非连续, 则同步一次所有消息
7. r 发送一个 ack_received 消息给服务器, 表示已收到该消息
    1. 该消息包含要确认消息的消息 ID, 要确认消息的发送者
    2. 该消息不需要保存, 不需要重试
8. 服务端收到 ack_received 后, 推送一条 ack_notify 接收者, 表示一个消息已被接收方确认收到
9. s 客户端收到 ack_notify 后, 将等待确认消息列表中的消息移除, 表示这条消息已发送成功

> s 发送消息的消息为上行消息, r 收到的消息为下行消息, 消息的定义请查阅 [message_def](message_def.md)

## 消息的同步

客户端同步消息的场景

- 客户端登录后, 主动同步群消息和拉取离线消息(单聊)
- 接收到消息, 接收到消息的用户全局 seq 与本地保存的大, 且不连续
- 一对一聊天时收到的消息seq和对应发送方的最后一条消息的 seq 不连续

### 客户端登录同步消息

1. 客户端登录
2. 客户端请求离线消息接口
3. 服务端根据用户 ID 查询离线消息表, 并返回给客户端
4. 客户端同步消息到相应的会话
5. 客户端请求群消息同步接口, 上传群最后一条消息 seq
6. 服务器根据群消息表, 返回 seq 大于客户端 seq 的消息到客户端
7. 客户端根据返回的群消息 id 查询具体消息内容

### 消息丢失同步

1. 客户端收到新消息
2. 新消息全局seq与本地不连续
3. 客户端访问消息同步接口, 上传本地全局seq
4. 服务端根据 seq 查询单聊消息表中 seq 大于客户端seq的消息
5. 客户端同步成功

> 单聊与群聊消息分为两张表保存, 消息表定义查看 [message_db_model](img/message_db_model.png)